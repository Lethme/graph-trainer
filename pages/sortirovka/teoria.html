<!DOCTYPE html>
<html lang="en">

<head>
    <title>Tree Brains</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="Project by No Walls Production" />
    <meta name="keywords" content="free bootstrap 4, free bootstrap 4 template, free website templates, free html5, free template, free website template, html5, css3, mobile first, responsive" />
    <meta name="author" content="No Walls Production" />
    <link rel="shortcut icon" href="assets/images/tree-logo.svg" type="image/x-icon">

    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="../../assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="../../assets/css/open-iconic-bootstrap.min.css">
    <link rel="stylesheet" href="../../assets/css/animate.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../../assets/css/owl.carousel.min.css">
    <link rel="stylesheet" href="../../assets/css/owl.theme.default.min.css">

    <link rel="stylesheet" href="../../assets/css/sortirovka.css">

    <link href="../../assets/css/prism.css" rel="stylesheet" />

    <link rel="stylesheet" href="../../assets/css/icomoon.css">
    <link rel="stylesheet" href="../../assets/css/style.css">
    <link rel="stylesheet" href="../../assets/css/left-nav-style.css">
</head>

<body class="sections-body" data-spy="scroll" data-target="#ftco-navbar" data-offset="200">
    <input type="checkbox" id="nav-toggle" hidden>
    <nav class="side-menu">
        <label for="nav-toggle" class="nav-toggle" onclick></label>
        <p class="side-menu-logo">
            <a href="../../index.html">Tree Brains</a>
            <p class="side-menu-section-name"><span>Балансировка</span></p>
        </p>
        <ul>
            <li><a href="teoria.html">Теория</a></li>
            <li><a href="trenajor.html">Тренировка</a></li>
            <li><a href="test.html">Тест</a></li>
        </ul>
    </nav>

    <nav class="navbar navbar-expand-lg navbar-light ftco_navbar bg-light ftco-navbar-light unselectable" id="ftco-navbar">
        <div class="container">
            <a class="navbar-brand" href="../../index.html">
                <div class="tree-logo tree-logo-dark"></div>Tree Brains</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#ftco-nav" aria-controls="ftco-nav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="oi oi-menu"></span> Menu
            </button>

            <div class="collapse navbar-collapse" id="ftco-nav">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item active"><a href="../../index.html" class="nav-link">Главная</a></li>
                    <li class="nav-item"><a href="../osnovi/teoria.html" class="nav-link">Основы</a></li>
                    <li class="nav-item"><a href="../obhodi/teoria.html" class="nav-link">Обходы деревьев</a></li>
                    <li class="nav-item"><a href="../sortirovka/teoria.html" class="nav-link">Балансировка</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <section class="osnovi-sections ftco-section bg-light ftco-slant ftco-slant-white unselectable content-section" id="section-features">
        <div class="container">
            <h3>Двоичная куча</h3>
            <p><strong>Двоичная куча</strong> – реализуемая структура данных, позволяющая быстро (за логарифмическое время) добавлять элементы и извлекать элемент с максимальным приоритетом.</p>
            <p>Двоичная куча представляет собой полное бинарное дерево, для которого выполняется <strong>основное свойство кучи</strong>: приоритет каждой вершины больше приоритетов её потомков. В простейшем случае приоритет каждой вершины можно считать равным её значению. В таком случае структура называется <strong>max-heap</strong>, поскольку корень поддерева является максимумом из значений элементов поддерева. Также, что дерево называется <strong>полным бинарным</strong>, если у каждой вершины есть не более двух потомков, а заполнение уровней вершин идет сверху вниз (в пределах одного уровня – слева направо).</p>
            <p>
                <img src="../../assets/images/sortirovka/1.png">
            </p>
            <p>
                Двоичную кучу удобно хранить в виде одномерного массива, причем левый потомок вершины с индексом <strong>i</strong> имеет индекс <strong>2*i+1</strong>, а правый <strong>2*i+2</strong>. Корень дерева – элемент с индексом 0. Высота двоичной кучи равна высоте дерева, то есть она равна количеству рёбер в самом длинном простом пути, соединяющем корень кучи с одним из её листьев.
            </p>
            <p>
                Высота кучи есть O(logN), где N — количество узлов дерева. Высота кучи определяется как высота двоичного дерева.
            </p>
            <p>
                Двоичная кура это такое двоичное дерево, для которого выполнены три условия:
            </p>
            <ol>
                <li>Значение в любой вершине не меньше, чем значения её потомков</li>
                <li>Глубина листьев (расстояние до корня) отличается не более чем на 1 слой</li>
                <li>Последний слой заполняется слева направо</li>
            </ol>
            <p>Существуют также кучи, где значение в любой вершине, наоборот, не больше, чем значения её потомков. Такие кучи называются <strong>min-heap</strong>, а кучи, описанные выше — <strong>max-heap</strong>. Удобная структура данных для сортирующего дерева — массив A, у которого первый элемент, A[1] — элемент в корне, а потомками элемента A[i] являются A[2i] и A[2i+1] (при нумерации элементов с первого). При нумерации элементов с нулевого, корневой элемент — A[0], а потомки элемента A[i] —A[2i+1] и A[2i+2]. При таком способе хранения условия 2 и 3 выполнены автоматически.</p>
            <p>Двоичную кучу удобно хранить в виде одномерного массива, причем</p>
            <ul>
                <li>Левый потомок вершины с индексом i имеет индекс 2*i+1,</li>
                <li>Правый потомок вершины с индексом i имеет индекс 2*i+2.</li>
            </ul>
            <p>
                <img src="../../assets/images/sortirovka/2.png">
            </p>
            <p><strong>Корень дерева</strong> – элемент с индексом 0. <strong>Высота двоичной кучи</strong> равна высоте дерева, то есть <strong>log2 (N+1)↑</strong>,где N – количество элементов массива, ↑ – округление в большую сторону до ближайшего целого.</p>
            <p>Для представленной кучи log2 (10+1)↑ = 3,46↑ = 4. Способ построить кучу из неупорядоченного массива – это по очереди добавить все его элементы. Временная оценка такого алгоритма оценивается как <strong>N·log2N</strong>.</p>
            <p>Можно построить кучу за N шагов. Для этого сначала следует построить дерево из всех элементов массива, не заботясь о соблюдении основного свойства кучи, а потом вызвать метод упорядочения для всех вершин, у которых есть хотя бы один потомок (так как поддеревья, состоящие из одной вершины без потомков, уже упорядочены).</p>
            <p>Потомки гарантированно есть у первых heapSize/2 вершин, где heapSize – размер кучи.</p>
            <div>
                <h4>Реализация класса кучи на языке С++</h4>
                <pre class="language-cpp">
                        <code class="language-cpp">
class Heap
{
  static const int SIZE = 100; // максимальный размер кучи
  int *h;         // указатель на массив кучи
  int HeapSize; // размер кучи
public:
  Heap();  // конструктор кучи
  void addelem(int);  // добавление элемента кучи
  void outHeap();  // вывод элементов кучи в форме кучи
  void out();  // вывод элементов кучи в форме массива
  int getmax();  // удаление вершины (максимального элемента)
  void heapify(int);  // упорядочение кучи
};
                        </code>
                </pre>
            </div>
            <div>
                <h4>Конструктор кучи на языке С++</h4>
               <pre class="language-cpp">
                        <code class="language-cpp">
Heap :: Heap()
{
  h = new int[SIZE];
  HeapSize = 0;
}                   </code>
                </pre>
            </div>

            <h4>Добавление элемента кучи</h4>
            <p>
                Новый элемент добавляется на последнее место в массиве, то есть позицию с максимальным индексом.
            </p>
            <p>
                Возможно, что при этом будет нарушено основное свойство кучи, так как новый элемент может быть больше родителя. В таком случае новый элемент «поднимается» на один уровень (менять с вершиной-родителем) до тех пор, пока не будет соблюдено основное свойство кучи.
            </p>
            <p>
                <img src="../../assets/images/sortirovka/3.png">
            </p>
            <p>
                <img src="../../assets/images/sortirovka/4.png">
            </p>
            <p>
                Сложность алгоритма не превышает высоты двоичной кучи (так как количество «подъемов» не больше высоты дерева), то есть равна <strong>log2 N</strong>.
            </p>
            <div>
                Реализация метода добавления элемента в кучуна языке С++
               <pre class="language-cpp">
                        <code class="language-c">
void Heap :: addelem(int n)
{
  int i, parent;
  i = HeapSize;
  h[i] = n;
  parent = (i-1)/2;
  while(parent >= 0 && i > 0)
  {
    if(h[i] > h[parent])
    {
      int temp = h[i];
      h[i] = h[parent];
      h[parent] = temp;
    }
    i = parent;
    parent = (i-1)/2;
  }
  HeapSize++;
}</code>
                </pre>
            </div>
            <div>
                <h4>Вывод элементов кучи</h4>
               <pre class="language-cpp">
                        <code class="language-c">
void Heap:: outHeap(void)
{
  int i = 0;
  int k = 1;
  while(i < HeapSize)
  {
    while((i < k) && (i < HeapSize))
    {
      cout << h[i] << " ";
      i++;
    }
    cout << endl;
    k = k * 2 + 1;
  }
}
               </code>
                </pre>
            </div>
            <div>
                <h4>Упорядочение кучи</h4>
               <pre class="language-cpp">
                        <code class="language-c">
void Heap:: heapify(int i)
{
  int left, right;
  int temp;
  left = 2*i+1;
  right = 2*i+2;
  if(left < HeapSize)
  {
    if(h[i] < h[left])
    {
      temp = h[i];
      h[i] = h[left];
      h[left] = temp;
      heapify(left);
    }
  }
  if(right < HeapSize)
  {
    if(h[i] < h[right])
    {
      temp = h[i];
      h[i] = h[right];
      h[right] = temp;
      heapify(right);
    }
  }
}
               </code>
                </pre>
            </div>
            <p>
                В упорядоченном <strong>max-heap</strong> максимальный элемент всегда хранится в корне. Восстановить упорядоченность двоичной кучи после удаления максимального элемента можно, поставив на его место последний элемент и вызвав метод упорядочения для корня, то есть упорядочив все дерево.
            </p>
            <div>
                <h4>Удаление вершины кучи (максимального элемента)</h4>
               <pre class="language-cpp">
                        <code class="language-c">
int getmax(void)
{
  int x;
  x = h[0];
  h[0] = h[HeapSize-1];
  HeapSize--;
  heapify(0);
  return(x);
}
               </code>
                </pre>
            </div>

            <h3>Пирамидальная сортировка</h3>
            <p>Пирамидальная сортировка была предложена Дж. Уильямсом в 1964 году. Это алгоритм сортировки массива произвольных элементов; требуемый им дополнительный объём памяти не зависит от количества исходных данных. Время работы алгоритма — O(n*ln*n) в среднем, а также в лучшем и худшем случаях.</p>
            <h4>Идея алгоритма</h4>
            <p>	Пирамида — двоичное дерево, в котором значение каждого элемента больше либо равно значений дочерних элементов.</p>
            <p>Заполнив дерево элементами в произвольном порядке, можно легко его отсортировать (легче, чем исходный список элементов), превратив в пирамиду. Самый большой элемент пирамиды находится в её вершине.</p>
            <ul>
                <li>Отделяем вершинный элемент, и записываем его в конец результирующего массива.</li>
                <li>На место вершинного элемента записываем элемент из самого нижнего уровня дерева.</li>
                <li>Восстанавливаем (пересортировываем) пирамиду.</li>
                <li>Самый большой элемент из оставшихся снова в вершине. Снова отделяем его и записываем его в качестве предпоследнего элемента результата, и так далее</li>
            </ul>
            <p>
                <strong>Возрастающей пирамидой</strong> называется почти заполненное дерево, в котором значение каждого элемента больше либо равно значений всех его потомков. Аналогично, в убывающей пирамидезначение каждого элемента меньше либо равно значений потомков.Возрастающей пирамидой называется почти заполненное дерево, в котором значение каждого элемента больше либо равно значений всех его потомков. Аналогично, в <strong>убывающей пирамидезначение</strong> каждого элемента меньше либо равно значений потомков.
            </p>
            <h4>Просеивание вверх</h4>
            <p>Рассмотрим теперь задачу присоединения элемента с произвольным значением к возрастающей пирамиде. Если просто добавить элемент в конец массива, то свойство пирамиды (значение любого элемента больше либо равно значения его родителя) может быть нарушено. Для восстановления свойства пирамиды к добавленному элементу применяется процедура <strong>просеивания вверх</strong>, которая описывается следующим алгоритмом:</p>
            <ol>
                <li>Если элемент корневой, или его значение меньше либо равно значения родителя, то <strong>конец</strong></li>
                <li>Меняем местами значения элемента и его родителя</li>
                <li>переходим к родителю, и выполняем для него этот же алгоритм, начиная с пункта 1</li>
            </ol>
            <p>
                Пример просеивания вверх добавленного элемента показан на рисунке:
            </p>
            <p>
                <img src="../../assets/images/sortirovka/6.png">
            </p>
            <h4>Просеивание вниз</h4>
            <p>Что делать, если нам нужно заменить корневой элемент на какой-либо другой? В этом случае пирамидальную структуру двоичного дерева можно восстановить с помощью процедуры <strong>просеивания вниз</strong>:</p>
            <ol>
                <li>если элемент листовой, или его значение больше или равен значений потомков, то конец;</li>
                <li>иначе меняем местами значения элемента и его потомка, имеющего максимальное значение;</li>
                <li>переходим к изменившемуся потомку, и выполняем для него этот же алгоритм, начиная с пункта 1.</li>
            </ol>
            <p>
                Пример просеивания вниз показан на рисунке:
            </p>
            <p>
                <img src="../../assets/images/sortirovka/7.png">
            </p>
            <div>
                <h4>Реализация процедуры просеивания вниз на языке C++</h4>
                <pre class="language-cpp">
                        <code class="language-c">
template&lt;class T&gt; void SiftDown(T* const heap, int i, int const n)
{   //Просеивает элемент номер i вниз в пирамиде heap.
    //n -- размер пирамиды

    //Индекс максимального элемента в текущей тройке элементов:
    int nMax( i );
    //Значение текущего элемента (не меняется):
    T const value( heap[i] );

    while ( true )
    { //Рассматривается элемент i и его потомки i*2+1 и i*2+2
      //В начале каждой итерации nMax == i и value == heap[i]

        int childN( i*2+1 ); //Индекс левого потомка
        //Если есть левый потомок и он больше текущего элемента,
        if ( ( childN < n ) && ( heap[childN] > value      ) )
            nMax = childN; //  то он считается максимальным

        ++childN; //Индекс правого потомка
        //Если есть правый потомок и он больше максимального,
        if ( ( childN < n ) && ( heap[childN] > heap[nMax] ) )
            nMax = childN; //  то он считается максимальным

        //Если текущий элемент является максимальным из трёх
        //  (т.е. если он больше своих детей), то конец:
        if ( nMax == i ) break;

        //Меняю местами текущий элемент с максимальным:
        heap[i] = heap[nMax]; heap[nMax] = value;
        //  при этом значение value будет в ячейке nMax,
        //  поэтому в начале следующей итерации значение value
        //  правильно, т.к. мы переходим именно к этой ячейке

        //Переходим к изменившемуся потомку
        i = nMax;

    };
}

               </code>
                </pre>
            </div>
            <h4>Сортировка</h4>
            <p>
                Имея построенную пирамиду, несложно реализовать сортировку. Так как корневой элемент пирамиды имеет самое большое значение, мы можем отделить его и поместить в отсортированный список. Вместо отсутствующего корневого элемента можно поставить последний (в смысле нумерации) элемент дерева и, просеяв его вниз, снова получить пирамиду.
            </p>
            <p>
                В новой уменьшенной пирамиде корень имеет самое большое значение среди оставшихся элементов. Его снова можно отделить и поместить в отсортированный список перед имеющимися там элементами, и так далее.
            </p>
            <p>Для хранения отсортированного списка будем использовать элементы исходного массива, освобождающиеся в результате уменьшения размера пирамиды. Алгоритм получается следующий:</p>
            <ol>
                <li>поменять местами значения первого и последнего элементов пирамиды;</li>
                <li>отделить последний элемент от дерева, уменьшив размер дерева на единицу (элемент остаётся в массиве);</li>
                <li>восстановить пирамиду, просеяв вниз её новый корневой элемент;</li>
                <li>перейти к пункту 1;</li>
            </ol>
            <p>По мере работы алгоритма, часть массива, занятая деревом, уменьшается, а в конце массива накапливается отсортированный результат.</p>
            <div>
                <h4>Реализация пирамидальной сортировки на языке  C++</h4>
                <pre class="language-cpp">
                        <code class="language-c">
template&lt;class T&gt; void HeapSort(T* const heap, int n)
{   //Пирамидальная сортировка массива heap.
    //  n -- размер массива

    //Этап 1: построение пирамиды из массива
    for(int i(n/2-1); i>=0; --i) SiftDown(heap, i, n);

    //Этап 2: сортировка с помощью пирамиды.
    //  Здесь под «n» понимается размер пирамиды
    while( n > 1 ) //Пока в пирамиде больше одного элемента
    {
        --n; //Отделяю последний элемент

        //Меняю местами корневой элемент и отделённый:
        T const firstElem( heap[0] );
        heap[0] = heap[n];
        heap[n] = firstElem;

        //Просеиваю новый корневой элемент:
        SiftDown(heap, 0, n);
    }
}
               </code>
                </pre>
            </div>
        </div>
    </section>

    <div id="btnTop" style="display: none;" class="unselectable">
        <a title="Go To Top" href="" class="btnTop"></a>
        <div id="top-arrow"></div>
    </div>

    <!-- <footer class="sections-footer ftco-footer ftco-bg-dark unselectable">
        <div class="container">
            <div class="row">
                <div class="col-md text-left">
                    <p>&copy; No Walls Production 2020. Все права защищены.</p>
                    <p>Учебный проект в рамках дисциплины "Типы и структуры данных"</p>
                </div>
                <div class="col-md-4">
                    <div class="ftco-footer-widget mb-4">
                        <ul class="ftco-footer-social list-unstyled float-md-right float-lft">
                            <li><a href="#"><span class="icon-twitter"></span></a></li>
                            <li><a href="#"><span class="icon-facebook"></span></a></li>
                            <li><a href="#"><span class="icon-instagram"></span></a></li>
                            <li><a href="#"><span class="icon-vk"></span></a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </footer> -->

    <div id="ftco-loader" class="show fullscreen"><svg class="circular" width="48px" height="48px">
            <circle class="path-bg" cx="24" cy="24" r="22" fill="none" stroke-width="4" stroke="#eeeeee" />
            <circle class="path" cx="24" cy="24" r="22" fill="none" stroke-width="4" stroke-miterlimit="10"
                stroke="#4586ff" /></svg></div>

    <script src="../../assets/js/jquery.min.js"></script>
    <script src="../../assets/js/popper.min.js"></script>
    <script src="../../assets/js/bootstrap.min.js"></script>
    <script src="../../assets/js/jquery.easing.1.3.js"></script>
    <script src="../../assets/js/jquery.waypoints.min.js"></script>
    <script src="../../assets/js/owl.carousel.min.js"></script>
    <script src="../../assets/js/jquery.animateNumber.min.js"></script>

    <script src="../../assets/js/main.js"></script>
    <script src="../../assets/js/main-scroll.js"></script>
    <script src="../../assets/js/prism.js"></script>
</body>

</html>