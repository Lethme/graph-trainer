<!DOCTYPE html>
<html lang="en">

<head>
    <title>Tree Brains</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="Project by No Walls Production" />
    <meta name="keywords" content="free bootstrap 4, free bootstrap 4 template, free website templates, free html5, free template, free website template, html5, css3, mobile first, responsive" />
    <meta name="author" content="No Walls Production" />
    <link rel="shortcut icon" href="../../assets/images/tree-logo.svg" type="image/x-icon">

    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="../../assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="../../assets/css/open-iconic-bootstrap.min.css">
    <link rel="stylesheet" href="../../assets/css/animate.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="../../assets/css/owl.carousel.min.css">
    <link rel="stylesheet" href="../../assets/css/owl.theme.default.min.css">

    <link rel="stylesheet" href="../../assets/css/osnovi.css">

    <link href="../../assets/css/prism.css" rel="stylesheet" />

    <link rel="stylesheet" href="../../assets/css/icomoon.css">
    <link rel="stylesheet" href="../../assets/css/style.css">
    <link rel="stylesheet" href="../../assets/css/left-nav-style.css">
</head>

<body class="sections-body" data-spy="scroll" data-target="#ftco-navbar" data-offset="200">
    <input type="checkbox" id="nav-toggle" hidden>
    <nav class="side-menu">
        <label for="nav-toggle" class="nav-toggle" onclick></label>
        <p class="side-menu-logo">
            <a href="../../index.html">Tree Brains</a>
            <p class="side-menu-section-name"><span>Основы</span></p>
        </p>
        <ul>
            <li><a href="teoria.html">Теория</a></li>
            <li><a href="trenajor.html">Тренировка</a></li>
            <li><a href="test.html">Тест</a></li>
        </ul>
    </nav>

    <nav class="navbar navbar-expand-lg navbar-light ftco_navbar bg-light ftco-navbar-light unselectable" id="ftco-navbar">
        <div class="container">
            <a class="navbar-brand" href="../../index.html">
                <div class="tree-logo tree-logo-dark"></div>
                Tree Brains</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#ftco-nav" aria-controls="ftco-nav" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="oi oi-menu"></span> Меню
                </button>

            <div class="collapse navbar-collapse" id="ftco-nav">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item active"><a href="../../index.html" class="nav-link">Главная</a></li>
                    <li class="nav-item"><a href="../osnovi/teoria.html" class="nav-link">Основы</a></li>
                    <li class="nav-item"><a href="../obhodi/teoria.html" class="nav-link">Обходы деревьев</a></li>
                    <li class="nav-item"><a href="../sortirovka/teoria.html" class="nav-link">Балансировка</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <section class="osnovi-sections ftco-section bg-light ftco-slant ftco-slant-white unselectable content-section" id="section-features">
        <div class="container">

            <div>
                <h3>Теория о деревьях</h3>

                <p><strong>Дерево</strong> — структура данных, представляющая собой древовидную структуру в виде набора связанных узлов.</p>

                <p><strong>Бинарное дерево</strong> — это конечное множество элементов, которое либо пусто, либо содержит элемент (корень), связанный с двумя различными бинарными деревьями, называемыми левым и правым поддеревьями. Каждый элемент бинарного
                    дерева называется узлом. Связи между узлами дерева называются его ветвями.
                    <br>Способ представления бинарного дерева:
                    <div><img src="../../assets/images/osnovi/tree.png"></div>
                    <div>A — корень дерева</div>
                    <div>В — корень левого поддерева</div>
                    <div>С — корень правого поддерева</div>
                    <br>
                    <p>Узел D, который находится непосредственно под узлом B, называется <strong>потомком</strong> B. Если D находится на уровне i, то B – на уровне i-1. Узел B называется <strong>предком</strong> D.</p>
                    <p>Максимальный уровень какого-либо элемента дерева называется его <strong>глубиной</strong> или <strong>высотой</strong>.
                    </p>
                    <p>Если элемент не имеет потомков, он называется <strong>листом</strong> или <strong>терминальным
                        узлом</strong> дерева.</p>
                    <p>Остальные элементы – <strong>внутренние узлы</strong> (узлы ветвления).</p>
                    <p>Число потомков внутреннего узла называется его <strong>степенью</strong>. Максимальная степень всех узлов есть степень дерева.</p>
                    <p>Каждый корень бинарного дерева является структурой, состоящей из четырех видов полей. Содержимым этих полей будут соответственно:</p>
                    <ol>
                        <li>информационное поле (ключ вершины)</li>
                        <li>служебное поле (их может быть несколько или ни одного)</li>
                        <li>указатель на левое поддерево</li>
                        <li>указатель на правое поддерево</li>
                    </ol>
                    <div>
                        Реализация структуры на языке С
                        <pre>
                        <code class="language-c">
struct BinaryTree{
    int Data; //поле данных
    BinaryTree* Left; //указатель на левый потомок
    BinaryTree* Right; //указатель на правый потомок
};
                        </code>
                    </pre>
                    </div>

                    <div>По степени вершин бинарные деревья делятся:</div>
                    <p><img src="../../assets/images/osnovi/vidi.png"></p>
                    <div><strong>Строгие</strong> – вершины дерева имеют степень ноль (у листьев) или два (у узлов)</div>
                    <div><strong>Нестрогие</strong> – вершины дерева имеют степень ноль (у листьев), один или два (у узлов).
                    </div>
                    <br>
                    <p>В общем случае у бинарного дерева на k -м уровне может быть до 2k-1 вершин. Бинарное дерево называется
                        <strong>полным</strong>, если оно содержит только полностью заполненные уровни. В противном случае оно является <strong>неполным</strong>.</p>
                    <p>Дерево называется <strong>сбалансированным</strong>, если длины всех путей от корня к внешним вершинам равны между собой. Дерево называется <strong>почти сбалансированным</strong>, если длины всевозможных путей от корня к внешним вершинам
                        отличаются не более, чем на единицу.</p>

                    <div>
                        Реализация создания бинарного дерева на языке С
                        <pre>
                        <code class="language-c">
void Make_Binary_Tree(BinaryTree** Node, int n){
  BinaryTree** ptr;//вспомогательный указатель
  srand(time(NULL)*1000);
  while (n > 0) {
    ptr = Node;
    while (*ptr != NULL) {
      if ((double) rand()/RAND_MAX < 0.5)
        ptr = &((*ptr)->Left);
      else ptr = &((*ptr)->Right);
    }
    (*ptr) = new BinaryTree();
    cout << "Введите значение ";
    cin >> (*ptr)->Data;
    n--;
  }
}</code>
                    </pre>
                    </div>
                    <br>
                    <div>
                        Реализация печати бинарного дерева на языке С
                        <pre>
                    <code class="language-c">
void Print_BinaryTree(BinaryTree* Node, int l){
    int i;
    if (Node != NULL) {
        Print_BinaryTree(Node->Right, l+1);
        for (i=0; i< l; i++) cout << "    ";
        printf ("%4ld", Node->Data);
        Print_BinaryTree(Node->Left, l+1);
    }
    else cout << endl;
}</code>
                    </pre>
                    </div>
                    <br>
                    <div>
                        Реализация вставка вершины в бинарное дерево на языке С
                        <pre>
                        <code class="language-c">
void Insert_Node_BinaryTree(BinaryTree** Node,int Data) {
  BinaryTree* New_Node = new BinaryTree;
  New_Node->Data = Data;
  New_Node->Left = NULL;
  New_Node->Right = NULL;
  BinaryTree** ptr = Node;//вспомогательный указатель
  srand(time(NULL)*1000);
  while (*ptr != NULL) {
    double q = (double) rand()/RAND_MAX;
    if ( q < 1/3.0) ptr = &((*ptr)->Left);
    else if ( q > 2/3.0) ptr = &((*ptr)->Right);
    else break;
  }
  if (*ptr != NULL) {
    if ( (double) rand()/RAND_MAX < 0.5 )
      New_Node->Left = *ptr;
    else New_Node->Right = *ptr;
    *ptr = New_Node;
  }
  else{
    *ptr = New_Node;
  }
}</code>
                    </pre>
                    </div>
                    <br>
                    <div>
                        Реализация удаление вершины из бинарного дерева на языке С
                        <pre>
                        <code class="language-c">
void Delete_Node_BinaryTree(BinaryTree** Node,int Data){
  if ( (*Node) != NULL ){
    if ((*Node)->Data == Data){
      BinaryTree* ptr = (*Node);
      if ( (*Node)->Left == NULL && (*Node)->Right == NULL ) (*Node) = NULL;
      else if ((*Node)->Left == NULL) (*Node) = ptr->Right;
      else if ((*Node)->Right == NULL) (*Node) = ptr->Left;
      else {
        (*Node) = ptr->Right;
        BinaryTree ** ptr1;
        ptr1 = Node;
        while (*ptr1 != NULL)
          ptr1 = &((*ptr1)->Left);
        (*ptr1) = ptr->Left;
      }
      delete(ptr);
      Delete_Node_BinaryTree(Node,Data);
    }
    else {
      Delete_Node_BinaryTree(&((*Node)->Left),Data);
      Delete_Node_BinaryTree(&((*Node)->Right),Data);
    }
  }
}</code>
                    </pre>
                        <h3>Бинарное дерево поиска</h3>
                        <div>Бинарное (двоичное) дерево поиска – это бинарное дерево, для которого выполняются следующие дополнительные условия (свойства дерева поиска):</div>
                        <ul>
                            <li>оба поддерева – левое и правое, являются двоичными деревьями поиска</li>
                            <li>у всех потомков левого поддерева значение узла X меньше или равно, чем значение узла предка X</li>
                            <li>у всех потомков правого поддерева значение узла Y больше, чем значение узла предка Y</li>
                        </ul>
                        <p>
                            Пример двоичного дерева поиска:
                        </p>
                        <p>
                            <img src="../../assets/images/osnovi/binary_search_tree.png">
                        </p>
                        <p>В процессе поиска элемента в дереве, мы сравниваем его со значением корня, если корень оказался больше — то нам нет смысла рассматривать правое поддерево (ведь там все значения еще больше). За счет этого на каждом сравнении «отсекается»
                            узлов дерева, а значит — мы получаем поиск с оценкой сложности <strong>O(log(n))</strong>.</p>

                        <p>Операция вставки выполняет добавление листа в дерево, то справа и слева от нового узла будет пусто (null). При вставке мы выполняем поиск подходящей свободной позиции, с учетом требования «значения вершин левого поддерева должны
                            всегда оказываться меньше или равны значению корневого узла, а правого – больше». Алгоритм вставки значения Х в дерево может выглядеть так:</p>
                        <ol>
                            <li>Если дерево является пустым – то X помещается в корневую вершину;</li>
                            <li>Если значение Х больше значения корневой вершины, то осуществляется вставка Х в правое поддерево (рекурсивно), иначе – в левое</li>
                        </ol>

                        <h3>Ключевые термины</h3>
                        <p><strong>Бинарное (двоичное) дерево</strong> – это дерево, в котором каждая вершина имеет не более двух потомков.</p>

                        <p><strong>Вершина (узел) дерева</strong> – это каждый элемент дерева.</p>

                        <p><strong>Ветви дерева</strong> – это направленные дуги, которыми соединены вершины дерева.</p>

                        <p><strong>Высота (глубина) дерева</strong> – это количество уровней, на которых располагаются его вершины.</p>

                        <p><strong>Дерево</strong> – это структура данных, представляющая собой совокупность элементов и отношений, образующих иерархическую структуру этих элементов.</p>

                        <p><strong>Корень дерева</strong> – это начальный узел дерева, ему соответствует нулевой уровень.</p>

                        <p><strong>Листья дерева</strong> – это вершины, в которые входит одна ветвь и не выходит ни одной ветви.</p>

                        <p><strong>Неполное бинарное дерево</strong> – это дерево, уровни которого заполнены не полностью.</p>

                        <p><strong>Нестрогое бинарное дерево</strong> – это дерево, у которого вершины имеют степень ноль (у листьев), один или два (у узлов).</p>

                        <p><strong>Обход дерева</strong> – это упорядоченная последовательность вершин дерева, в которой каждая вершина встречается только один раз.</p>

                        <p><strong>Поддерево</strong> – это часть древообразной структуры данных, которая может быть представлена в виде отдельного дерева.</p>

                        <p><strong>Полное бинарное дерево</strong> – это дерево, которое содержит только полностью заполненные уровни.</p>

                        <p><strong>Потомки</strong> – это все вершины, в которые входят ветви, исходящие из одной общей вершины.</p>

                        <p><strong>Почти сбалансированное дерево</strong> – это дерево, у которого длины всевозможных путей от корня к внешним вершинам отличаются не более, чем на единицу.</p>

                        <p><strong>Предок</strong> – это вершина, из которой исходят ветви к вершинам следующего уровня.</p>

                        <p><strong>Сбалансированное дерево</strong> – это дерево, у которого длины всех путей от корня к внешним вершинам равны между собой.</p>

                        <p><strong>Степень вершины</strong> – это количество дуг, которое выходит из этой вершины.</p>

                        <p><strong>Степень дерева</strong> – это максимальная степень вершин, входящих в дерево.</p>

                        <p><strong>Строгое бинарное дерево</strong> – это дерево, у которого вершины имеют степень ноль (у листьев) или два (у узлов).</p>

                        <p><strong>Упорядоченное дерево</strong> – это дерево, у которого ветви, исходящие из каждой вершины, упорядочены по определенному критерию.</p>

                        <p><strong>Уровень вершины</strong> – это количество дуг от корня дерева до вершины.</p>
                    </div>
                    <br>
                    <!-- <p class="mb-0"><a href="#" class="btn btn-primary btn-sm">Learn
                        More</a></p> -->
            </div>

        </div>
    </section>

    <div id="btnTop" style="display: none;" class="unselectable">
        <a title="Go To Top" href="" class="btnTop"></a>
        <div id="top-arrow"></div>
    </div>

    <!-- <footer class="sections-footer ftco-footer ftco-bg-dark unselectable">
            <div class="container">
                <div class="row">
                    <div class="col-md text-left">
                        <p>&copy; No Walls Production 2020. Все права защищены.</p>
                        <p>Учебный проект в рамках дисциплины "Типы и структуры данных"</p>
                    </div>
                    <div class="col-md-4">
                        <div class="ftco-footer-widget mb-4">
                            <ul class="ftco-footer-social list-unstyled float-md-right float-lft">
                                <li><a href="#"><span class="icon-twitter"></span></a></li>
                                <li><a href="#"><span class="icon-facebook"></span></a></li>
                                <li><a href="#"><span class="icon-instagram"></span></a></li>
                                <li><a href="#"><span class="icon-vk"></span></a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </footer> -->

    <div id="ftco-loader" class="show fullscreen">
        <svg class="circular" width="48px" height="48px">
                <circle class="path-bg" cx="24" cy="24" r="22" fill="none" stroke-width="4" stroke="#eeeeee"/>
                <circle class="path" cx="24" cy="24" r="22" fill="none" stroke-width="4" stroke-miterlimit="10"
                        stroke="#4586ff"/>
            </svg>
    </div>

    <script src="../../assets/js/jquery.min.js"></script>
    <script src="../../assets/js/popper.min.js"></script>
    <script src="../../assets/js/bootstrap.min.js"></script>
    <script src="../../assets/js/jquery.easing.1.3.js"></script>
    <script src="../../assets/js/jquery.waypoints.min.js"></script>
    <script src="../../assets/js/owl.carousel.min.js"></script>
    <script src="../../assets/js/jquery.animateNumber.min.js"></script>

    <script src="../../assets/js/main.js"></script>
    <script src="../../assets/js/main-scroll.js"></script>
    <script src="../../assets/js/prism.js"></script>
</body>

</html>